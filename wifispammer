#!/usr/bin/env python3
# Windows WiFi Network Generator
# A script that creates multiple Wi-Fi network profiles rapidly on Windows

import os
import sys
import time
import json
import random
import string
import argparse
import subprocess
import platform
import threading
from pathlib import Path
import importlib.util


def check_and_install_dependencies():
    # Check for required packages and install them if missing
    required_packages = ["pyyaml", "rich", "inquirer", "faker", "pywin32"]
    
    for package in required_packages:
        if importlib.util.find_spec(package) is None:
            print(f"Installing required package: {package}")
            subprocess.check_call([sys.executable, "-m", "pip", "install", package])
    
    # Now we can safely import the packages we need
    global yaml, Console, inquirer, Faker
    import yaml
    from rich.console import Console
    import inquirer
    from faker import Faker


class WiFiSpammer:
    def __init__(self, config_path=None):
        # Initialize the WiFi Spammer with path to config file
        self.console = Console()
        
        # Check if running on Windows
        if platform.system().lower() != "windows":
            self.console.print("[bold red]This script only works on Windows![/bold red]")
            sys.exit(1)
            
        if config_path:
            self.config_path = Path(config_path)
        else:
            self.config_path = Path.home() / ".wifi_spammer_config.yml"
        
        # Load or create config
        self.config = self.load_config()
        self.faker = Faker()
        
        # Track created networks
        self.created_networks = []
        self.running = False
        self.start_time = None
        
        # Keep track of total networks created
        self.total_networks_created = 0
        
    def load_config(self):
        # Load configuration file or create a default one if it doesn't exist
        if self.config_path.exists():
            with open(self.config_path, 'r') as f:
                try:
                    return yaml.safe_load(f)
                except yaml.YAMLError:
                    self.console.print("[bold red]Error loading config file. Using defaults.[/bold red]")
        
        # Default configuration
        default_config = {
            "profiles": {},
            "prefix": "WiFi-",
            "batch_size": 10,
            "delay_between_batches": 0.5,
            "security_types": ["WPA2"],
            "include_password": True,
            "password_length": 12
        }
        
        # Save default config
        with open(self.config_path, 'w') as f:
            yaml.dump(default_config, f)
        
        return default_config
    
    def save_config(self):
        # Save the current configuration to file
        with open(self.config_path, 'w') as f:
            yaml.dump(self.config, f)
    
    def generate_random_ssid(self):
        # Generate a random SSID
        prefix = self.config.get("prefix", "WiFi-")
        
        # Different SSID generation methods
        methods = [
            # Random string of characters
            lambda: f"{prefix}{random.choice(string.ascii_uppercase)}{random.choice(string.digits)}{random.choice(string.ascii_uppercase)}-{random.randint(100, 999)}",
            
            # Company style networks
            lambda: f"{self.faker.company().replace(' ', '')}-Guest",
            lambda: f"{self.faker.company().replace(' ', '')}-5G",
            
            # Home style networks
            lambda: f"{self.faker.last_name()}{random.choice(['WiFi', 'Net', 'Home'])}-{random.randint(10, 99)}",
            
            # Device names
            lambda: f"{random.choice(['iPhone', 'Galaxy', 'Pixel', 'Huawei'])}-{random.randint(100, 999)}",
            
            # ISP-style names
            lambda: f"{random.choice(['Xfinity', 'Spectrum', 'ATT', 'Verizon', 'TMobile'])}-{random.randint(100, 999)}"
        ]
        
        # Choose a random method
        return random.choice(methods)()
    
    def generate_random_password(self):
        # Generate a random password
        if not self.config.get("include_password", True):
            return None
            
        length = self.config.get("password_length", 12)
        chars = string.ascii_letters + string.digits + '!@#$%^&*()_+'
        return ''.join(random.choice(chars) for _ in range(length))
    
    def create_network_profile(self):
        # Create a random network profile
        ssid = self.generate_random_ssid()
        password = self.generate_random_password()
        security = random.choice(self.config.get("security_types", ["WPA2"]))
        hidden = random.random() < 0.1  # 10% chance of being hidden
        
        profile = {
            "password": password,
            "hidden": hidden,
            "security": security,
            "created_time": time.time()
        }
        
        self.config["profiles"][ssid] = profile
        self.created_networks.append(ssid)
        return ssid, profile
    
    def create_xml_profile(self, ssid, profile):
        # Create a Windows XML profile for the network
        xml_content = f"""<?xml version="1.0"?>
<WLANProfile xmlns="http://www.microsoft.com/networking/WLAN/profile/v1">
    <name>{ssid}</name>
    <SSIDConfig>
        <SSID>
            <name>{ssid}</name>
        </SSID>
        <nonBroadcast>{str(profile['hidden']).lower()}</nonBroadcast>
    </SSIDConfig>
    <connectionType>ESS</connectionType>
    <connectionMode>auto</connectionMode>
    <MSM>
        <security>
            <authEncryption>
                <authentication>{profile['security']}</authentication>
                <encryption>AES</encryption>
                <useOneX>false</useOneX>
            </authEncryption>
            <sharedKey>
                <keyType>passPhrase</keyType>
                <protected>false</protected>
                <keyMaterial>{profile['password']}</keyMaterial>
            </sharedKey>
        </security>
    </MSM>
</WLANProfile>
"""
        filename = f"{ssid.replace(' ', '_')}.xml"
        with open(filename, "w") as f:
            f.write(xml_content)
        return filename
    
    def add_profile_to_system(self, ssid, profile):
        # Add the profile to the system's network list
        try:
            xml_file = self.create_xml_profile(ssid, profile)
            cmd = f'netsh wlan add profile filename="{xml_file}" user=current'
            subprocess.call(cmd, shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            os.remove(xml_file)
            self.total_networks_created += 1  # Increment counter when successfully added
            return True
                
        except Exception as e:
            self.console.print(f"[bold red]Error adding profile: {str(e)}[/bold red]")
            return False
    
    def create_networks_batch(self, count):
        # Create a batch of random networks
        successful = 0
        
        for _ in range(count):
            if not self.running:
                break
                
            ssid, profile = self.create_network_profile()
            if self.add_profile_to_system(ssid, profile):
                successful += 1
                self.console.print(f"[green]Created network: {ssid}[/green]")
            else:
                self.console.print(f"[yellow]Failed to create network: {ssid}[/yellow]")
        
        return successful
    
    def get_generated_networks_count(self):
        # Get the number of networks generated so far
        return self.total_networks_created
    
    def show_generated_networks_count(self):
        # Show count of networks generated
        count = self.get_generated_networks_count()
        self.console.print(f"[bold cyan]Total WiFi networks generated: {count}[/bold cyan]")
    
    def start_spamming(self, count=None, batch_size=None, delay=None):
        # Start creating multiple Wi-Fi networks rapidly
        if batch_size is None:
            batch_size = self.config.get("batch_size", 10)
            
        if delay is None:
            delay = self.config.get("delay_between_batches", 0.5)
        
        self.running = True
        self.start_time = time.time()
        total_created = 0
        
        try:
            self.console.print("[bold green]Starting Wi-Fi network generation...[/bold green]")
            
            while self.running:
                if count is not None and total_created >= count:
                    self.console.print(f"[bold green]Reached target count of {count} networks[/bold green]")
                    break
                
                created = self.create_networks_batch(batch_size)
                total_created += created
                
                elapsed = time.time() - self.start_time
                rate = total_created / elapsed if elapsed > 0 else 0
                
                self.console.print(f"[bold]Created {total_created} networks ({rate:.2f}/sec)[/bold]")
                self.show_generated_networks_count()  # Show total network count
                
                if delay > 0:
                    time.sleep(delay)
            
        except KeyboardInterrupt:
            self.console.print("[bold yellow]Stopping network generation...[/bold yellow]")
        finally:
            self.running = False
            self.save_config()
            
            elapsed = time.time() - self.start_time
            rate = total_created / elapsed if elapsed > 0 else 0
            
            self.console.print(f"[bold]Total networks created in this run: {total_created}[/bold]")
            self.console.print(f"[bold]Average rate: {rate:.2f} networks/second[/bold]")
            self.console.print(f"[bold]Total time: {elapsed:.2f} seconds[/bold]")
            self.show_generated_networks_count()  # Show final count
    
    def stop_spamming(self):
        # Stop the network generation process
        self.running = False
    
    def list_created_networks(self):
        # List all created networks
        if not self.created_networks:
            self.console.print("[yellow]No networks have been created yet.[/yellow]")
            self.show_generated_networks_count()  # Show count even if none in this session
            return
        
        self.console.print("[bold]Created Networks:[/bold]")
        for i, ssid in enumerate(self.created_networks):
            profile = self.config["profiles"].get(ssid, {})
            hidden = " [hidden]" if profile.get("hidden", False) else ""
            security = profile.get("security", "Unknown")
            self.console.print(f"{i+1}. {ssid}{hidden} ({security})")
        
        self.show_generated_networks_count()  # Show total count
    
    def cleanup_networks(self):
        # Attempt to clean up created networks
        self.console.print("[bold]Cleaning up created networks...[/bold]")
        
        cleaned = 0
        for ssid in self.created_networks:
            try:
                cmd = f'netsh wlan delete profile name="{ssid}"'
                subprocess.call(cmd, shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                cleaned += 1
                self.total_networks_created -= 1  # Decrement counter for each cleaned network
            except Exception:
                pass
        
        self.console.print(f"[green]Cleaned up {cleaned} networks[/green]")
        self.show_generated_networks_count()  # Show updated count


def main():
    # Main function to process command-line arguments
    # Install dependencies first
    check_and_install_dependencies()
    
    # Parse arguments
    parser = argparse.ArgumentParser(description="Windows Wi-Fi Network Generator")
    subparsers = parser.add_subparsers(dest="command", help="Command to execute")
    
    # Spam networks command
    spam_parser = subparsers.add_parser("spam", help="Create multiple Wi-Fi networks")
    spam_parser.add_argument("--count", "-c", type=int, help="Number of networks to create (default: unlimited)")
    spam_parser.add_argument("--batch", "-b", type=int, help="Batch size for network creation")
    spam_parser.add_argument("--delay", "-d", type=float, help="Delay between batches in seconds")
    spam_parser.add_argument("--prefix", "-p", help="Prefix for generated SSIDs")
    
    # List created networks command
    subparsers.add_parser("list", help="List created networks")
    
    # Cleanup networks command
    subparsers.add_parser("cleanup", help="Attempt to clean up created networks")
    
    # Count networks command
    subparsers.add_parser("count", help="Show total number of networks generated")
    
    # Config file option
    parser.add_argument("--config", help="Path to config file")
    
    args = parser.parse_args()
    
    # Initialize WiFi Spammer
    spammer = WiFiSpammer(config_path=args.config)
    
    # Execute command
    if args.command == "spam":
        if args.prefix:
            spammer.config["prefix"] = args.prefix
            spammer.save_config()
            
        spammer.start_spamming(count=args.count, batch_size=args.batch, delay=args.delay)
    elif args.command == "list":
        spammer.list_created_networks()
    elif args.command == "cleanup":
        spammer.cleanup_networks()
    elif args.command == "count":
        spammer.show_generated_networks_count()
    else:
        # If no command is provided, default to help
        parser.print_help()


if __name__ == "__main__":
    main()